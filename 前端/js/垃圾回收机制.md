### JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。

## 标记清除

> js中最长用的垃圾收集方式就是标记清除

> 当运行addTen()这个函数的时候，就是当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

```
1 function addTen(num){  
2     var sum += num;  //垃圾收集已将这个变量标记为“进入环境”。
3     return sum;      //垃圾收集已将这个变量标记为“离开环境”。
4 }
5 addTen(10);  //输出20

```

##### 释放内存案例

```
var user = {name : 'scott', age : '21', gender : 'male'}; //在全局中定义变量，标记变量为“进入环境”

user = null;  //最后定义为null，释放内存

```

> 　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

## 引用计数

> 另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。

> 当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存



[引用文章](https://www.cnblogs.com/scottjeremy/p/6870729.html)

